<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minew G1-E LED Status Prototype</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 20px; background-color: #121212; color: #EEEEEE; }
    #led-ring { position: relative; width: 300px; height: 300px; margin: 20px auto; }
    .led { position: absolute; width: 20px; height: 20px; border-radius: 50%; background: #000; transition: background 0.3s, opacity 0.3s; }
    @keyframes rotate-sweep { 0% { background: rgba(255,255,255,0.1); } 50% { background: rgba(255,255,255,0.8); } 100% { background: rgba(255,255,255,0.1); } }
    @keyframes blink-1hz   { 0%,50% { opacity: 1; } 51%,100% { opacity: 0; } }
    @keyframes blink-5hz   { 0%,50% { opacity: 1; } 51%,100% { opacity: 0; } }
    @keyframes strobe-10hz { 0%,50% { opacity: 1; } 51%,100% { opacity: 0; } }
    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    .rotate      { animation: rotate-sweep 3s linear infinite; }
    .blink-1hz   { animation: blink-1hz   1s step-end infinite; }
    .blink-5hz   { animation: blink-5hz   0.2s step-end infinite; }
    .strobe-10hz { animation: strobe-10hz 0.1s step-end infinite; }
    .pulse       { animation: pulse 2s ease-in-out infinite; }
    #controls select, #controls button, #controls .nav-btn { padding: 8px; margin: 5px; background-color: #333; color: #EEE; border: 1px solid #555; border-radius: 4px; }
    #controls button:hover, #controls .nav-btn:hover { background-color: #444; }
    #scenarios button { padding: 6px 12px; margin: 4px; background: #222; color: #EEE; border: 1px solid #555; border-radius: 4px; }
    #scenarios button:hover { background: #333; }
  </style>
</head>
<body>
  <h1>Minew G1-E LED Status Prototype</h1>
  <p>Trigger LED states via the <strong>State selector</strong> or run <strong>Scenarios</strong> below.</p>
  <div id="led-ring"></div>
  <div id="controls">

    <button class="nav-btn" id="prev-btn">&larr; Previous</button>
    <select id="state-select"></select>
    <button class="nav-btn" id="next-btn">Next &rarr;</button>

  </div>
  <div id="scenarios">
    <h3>Scenarios</h3>
    <button onclick="runScenario('boot')">Boot Flow</button>
    <button onclick="runScenario('provision')">Provision Flow</button>
    <button onclick="runScenario('reset')">Reset Flow</button>
    <button onclick="runScenario('maintenance')">Maintenance Flow</button>
    <button onclick="runScenario('error')">Error Flow</button>
    <button onclick="runScenario('errors')">Errors</button>
  </div>
  <script>

    const ring = document.getElementById('led-ring');
    const stateSelect = document.getElementById('state-select');
    const applyBtn   = document.getElementById('apply-btn');
    const prevBtn    = document.getElementById('prev-btn');
    const nextBtn    = document.getElementById('next-btn');
    const scenarioButtons = document.querySelectorAll('#scenarios button');

    const numLEDs = 24, leds = [], radius = 120;
    let walkInterval, scenarioTimeout;
    // Create LEDs
    for (let i=0; i<numLEDs; i++) {
      const d = document.createElement('div'); d.classList.add('led');
      const a = (i/numLEDs)*2*Math.PI;
      d.style.left = `${radius+Math.cos(a)*radius-10}px`;
      d.style.top  = `${radius+Math.sin(a)*radius-10}px`;
      ring.appendChild(d);
      leds.push(d);
    }
    // State definitions
    const states = {
      OFF: { base:'#000000', anim:'', walk:false },
      BOOTLOADER: { base:'rainbow', anim:'', walk:false },
      STARTUP_MAINTENANCE: { base:'#FFFFFF', anim:'', walk:false },
      BACNET_CONFIG_UPDATE: { base:'#FFFFFF', anim:'', walk:true, colorDot:'#FFA500' },
      SW_UPDATE: { base:'#FFFFFF', anim:'', walk:true, colorDot:'#FFA500', dotCount:2 },
      ERROR_BACNET_CONFIG_UPDATE: { base:'#FFFFFF', anim:'', walk:false, colorDot:'#FF0000' },
      ERROR_SW_UPDATE: { base:'#FFFFFF', anim:'', walk:false, colorDot:'#FF0000', dotCount:2 },
      NO_ACTION: { base:'#FFFFFF', anim:'pulse', walk:false },
      RESET_FACTORY: { base:'#FFFFFF', anim:'blink-1hz', walk:false },
      LOG_BACKUP_LOCAL: { base:'#FFA500', anim:'', walk:true, colorDot:'#0000FF' },
      BACNET_SERVICE_STARTING: { base:'#FFA500', anim:'pulse', walk:false },
      BACNET_SERVER_CONFIGURING: { base:'#FFA500', anim:'', walk:true, colorDot:'#000' },
      UNPROVISIONED: { base:'#FFFF00', anim:'', walk:false },
      ATTENTION_UNPROV: { base:'#FFFF00', anim:'blink-1hz', walk:false },
      PROVISIONED: { base:'#00FF00', anim:'', walk:false },
      FULL_OPERATIONAL: { base:'#008000', anim:'', walk:false },
      ATTENTION_PROV: { base:'#00FF00', anim:'blink-1hz', walk:false },
      LOG_BACKUP_REMOTE: { base:'#800080', anim:'', walk:true, colorDot:'#0000FF' },
      REMOTE_RESTART: { base:'#800080', anim:'blink-1hz', walk:false },
      ERROR_SYNTAX: { base:'#000000', anim:'', walk:false, colorDot:'#FF0000'},
      ERROR_CFG: { base:'#000000', anim:'', walk:false, colorDot:'#FF0000', dotCount:2 },
      ERROR_UNRESPONSIVE: { base:'#000000', anim:'', walk:false, colorDot:'#FF0000', dotCount:3 },
      ERROR_BACKUP: { base:'#000000', anim:'', walk:false, colorDot:'#FF0000', dotCount:4},
      ERROR_CRASH: { base:'#FF0000', anim:'', walk:false}
    };

    const stateKeys = Object.keys(states);

    // Populate selector
    stateKeys.forEach(key => {
      const opt = document.createElement('option'); opt.value = key; opt.textContent = key.replace(/_/g,' ');
      stateSelect.appendChild(opt);
    });


    function clearTimers(){ clearInterval(walkInterval); clearTimeout(scenarioTimeout); }
    function applyState(name){
      clearTimers();
      const cfg = states[name];
      leds.forEach(ld=>{ ld.className='led'; ld.style.opacity=1; ld.style.boxShadow='none'; });
      leds.forEach((ld,i)=>{
        ld.style.background = cfg.base==='rainbow' ? `hsl(${i/24*360},100%,50%)` : cfg.base;
        ld.baseColor = ld.style.background;
      });
      // Static dot overlay for non-walking states
      if (!cfg.walk && cfg.colorDot) {
        const hex = cfg.colorDot.replace('#','');
        const r = parseInt(hex.substr(0,2),16);
        const g = parseInt(hex.substr(2,2),16);
        const b = parseInt(hex.substr(4,2),16);
        const count = cfg.dotCount || 1;
        for (let k=0; k<count; k++) {
          const idx = Math.floor(k*(numLEDs/count)) % numLEDs;
          // center
          leds[idx].style.background = cfg.colorDot;
          leds[idx].style.boxShadow = `0 0 12px 6px ${cfg.colorDot}`;
          // diffusion neighbors
          [1,2].forEach(d=>{
            const intensity = d===1?0.5:0.25;
            [ (idx+d)%numLEDs, (idx-d+numLEDs)%numLEDs ].forEach(n=>{
              leds[n].style.background = `rgba(${r},${g},${b},${intensity})`;
            });
          });
        }
      }
      // Moving dot logic with diffusion
      if (cfg.walk) {
        let pos = 0;
        walkInterval = setInterval(() => {
          leds.forEach(ld=>{
            ld.style.background = ld.baseColor;
            ld.style.boxShadow = 'none';
          });
          const hex = cfg.colorDot.replace('#','');
          const dotR=parseInt(hex.substr(0,2),16);
          const dotG=parseInt(hex.substr(2,2),16);
          const dotB=parseInt(hex.substr(4,2),16);
          const count = cfg.dotCount || 1;
          for (let k=0; k<count; k++) {
            const idx = (pos + Math.floor(k*(numLEDs/count))) % numLEDs;
            // center
            leds[idx].style.background = cfg.colorDot;
            leds[idx].style.boxShadow = `0 0 12px 6px ${cfg.colorDot}`;
            // diffusion neighbors
            [1,2].forEach(d=>{
              const intensity = d===1?0.5:0.25;
              [(idx+d)%numLEDs, (idx-d+numLEDs)%numLEDs].forEach(n=>{
                leds[n].style.background = `rgba(${dotR},${dotG},${dotB},${intensity})`;
              });
            });
          }
          pos = (pos + 1) % numLEDs;
        }, 200);
      }
      if (cfg.anim) leds.forEach(ld=>ld.classList.add(cfg.anim));
      document.getElementById('state-select').value = name;
    }

    // Next / Prev
    document.getElementById('next-btn').onclick = () => {
      const idx = stateKeys.indexOf(stateSelect.value);
      applyState(stateKeys[(idx+1)%stateKeys.length]);
    };
    document.getElementById('prev-btn').onclick = () => {
      const idx = stateKeys.indexOf(stateSelect.value);
      applyState(stateKeys[(idx-1+stateKeys.length)%stateKeys.length]);
    };

    // Change on select
    stateSelect.onchange = () => applyState(stateSelect.value);

    const scenarios = {
      boot: ['OFF','BOOTLOADER','STARTUP_MAINTENANCE','BACNET_CONFIG_UPDATE','BACNET_SERVICE_STARTING','BACNET_SERVER_CONFIGURING','BACNET_SERVICE_STARTING','UNPROVISIONED'],
      provision: ['UNPROVISIONED','ATTENTION_UNPROV','PROVISIONED','FULL_OPERATIONAL'],
      reset: ['RESET_FACTORY','BOOTLOADER','STARTUP_MAINTENANCE','BACNET_SERVICE_STARTING','BACNET_SERVER_CONFIGURING','BACNET_SERVICE_STARTING','UNPROVISIONED'],
      maintenance: ['LOG_BACKUP_REMOTE', 'ERROR_BACKUP', 'BACNET_SERVICE_STARTING', 'PROVISIONED','FULL_OPERATIONAL' ],
      error: ['OFF','BOOTLOADER','STARTUP_MAINTENANCE','BACNET_CONFIG_UPDATE','BACNET_SERVICE_STARTING','BACNET_SERVER_CONFIGURING','BACNET_SERVICE_STARTING','UNPROVISIONED','ERROR_CFG', 'BACNET_SERVICE_STARTING','BACNET_SERVER_CONFIGURING','BACNET_SERVICE_STARTING','UNPROVISIONED','ERROR_CFG'],      
      errors: ['ERROR_SYNTAX','ERROR_CFG','ERROR_UNRESPONSIVE','ERROR_BACKUP','ERROR_CRASH']
    };
    function runScenario(key,i=0){ const seq=scenarios[key]; if(i>=seq.length) return; applyState(seq[i]); scenarioTimeout = setTimeout(() => runScenario(key,i+1), 3000); }
    applyState('OFF');
  </script>
</body>
</html>